# MAP
# POSITIVE 
map4x4=[[0, 0, 1, 1],
        [0, 0, 0, 1],
        [0, 1, 0, 0],
        [0, 1, 1, 0]]
       
# POSITIVE 
map9x9=[[0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 0, 1, 1, 1, 0, 1],
        [1, 0, 0, 0, 0, 1, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
        [1, 1, 0, 0, 0, 0, 0, 1, 0, 1],
        [1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
        [1, 0, 0, 1, 1, 1, 0, 0, 0, 1],
        [1, 0, 1, 1, 1, 1, 1, 0, 1, 1],
        [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]]

# NEGATIVE TEST CASE
map16x16n=[[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
    [1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0],
    [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
    [0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0],
    [0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
    [0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0],
    [1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0],
    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0],
    [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0],
    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],
    [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0],
    [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0],
    [1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0]]

# POSITIVE TEST CASE
map16x16=[[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
    [1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0],
    [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
    [0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0],
    [0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0],
    [0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0],
    [1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0],
    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0],
    [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0],
    [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],
    [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0],
    [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0],
    [1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0]]

# CHOOSE MAP
MAP:list[list[int]]=map16x16 # ONLY EDIT THIS

# DIMENSIONS
map_width=len(MAP)
map_height=len(MAP)
BLOCKED=darkgreen # these represent walls that are not traversable
FREE=cream # these free roads are traversable
EXPLORED=orange # these represent which blocks have been explored by the algo
PATH=blue # these represents the clear path from start to finish

# INIT MAP
canvas(0, 0, map_width, map_height)
resolution(map_width, map_height)
noupdate()
for y in range(map_width):
    for x in range(map_height):
        if (MAP[y][x]):
            pixset(x, y, BLOCKED)
        else:
            pixset(x, y, FREE)
update()

# MAP VARS
start_x=0 # we always start on top left [0, 0]
start_y=0
end_x=map_height-1 # we end at bottom right [length-1, length-1]
end_y=map_width-1

# MAP LISTS
route: list[list[int]] = [] # route taken by the algorithm
visited: list[list[int]] = [] # keeps track of what has been visited
FOUND=False # keep track if a clear path to exit has been found

# DFS
def dfs(x:int, y:int, end_x:int, end_y:int, map:list[list[int]]):
    if (x == end_x) and (y == end_y): # check if the current position is the destination
        return True
        
    pixset(x, y, EXPLORED) # we explore this new block
    # print("Traversed", x, y)
    
    directions = [[0, 1], [1, 0], [0, -1], [-1, 0]] # directions to move: right, down, left, up
    for coord in directions:
        nx =(x + coord[0]) 
        ny =(y + coord[1]) # adjacent coordinate
        if is_valid(ny, nx, map) and not is_visited(nx, ny):  # check if within bounds and not blocked
            visited.append([nx, ny]) # the set neighbours as visited
            if (dfs(nx, ny, end_x, end_y, map)): # if path to finish is found
                pixset(nx, ny, PATH) # set the path to finish
                route.append([nx, ny])
                return True
            visited.remove([nx, ny]) # backtracking
        else:
            continue

# Checks if cell is visited
def is_visited(x, y):
    coord:list[int]=[x,y]
    if(coord in visited):
        return True
    else:
        return False

# Helper function to check whether block is available
def is_valid(x, y, map):
    if (x < 0) or (x >= map_width) or (y < 0) or (y >= map_height):
        return False
    elif (map[x][y]):
        return False
    elif (not([x, y]) in visited):
        return False
    else:
        return True
      
# Start DFS from the entrance [0,0] and end at end
visited.append([start_x, start_y])
FOUND=dfs(start_x, start_y, end_x, end_y, MAP)
route.append([start_x, start_y])
pixset(start_x, start_y, PATH)

# Reconstruct the path in order
if FOUND:
    route.reverse() # might not work if the matrix is too large, limited memory
    print("Path found:", route)
    print("Horray! :)")
else:
    print("No path found :(")
